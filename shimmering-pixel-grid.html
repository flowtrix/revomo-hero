<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shimmering Pixel-Grid Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            color: #000000;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .dot-field {
            width: 100vw;
            height: 100vh;
            margin: 2rem auto;
            /* Center the canvas */
        }
    </style>
</head>

<body>
    <div class="dot-field"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js" integrity="sha512-WoO4Ih0CDOSLYafy22wZD/mcJ7k0ESLqtQsFa6zFKnEUrbtuGU+GkLtVhgt93xa2qewG5gKEC6CWlN8OaCTSVg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script type="module">
        const container = document.querySelector('.dot-field');

        const app = new PIXI.Application({

            width: container.clientWidth,

            height: container.clientHeight,

            backgroundColor: 0x0D0C14,

            backgroundAlpha: 1,

            antialias: true,

            autoDensity: true,

            resolution: window.devicePixelRatio,

        });

        container.appendChild(app.view);

        const fragmentShader = `

            precision mediump float;

            varying vec2 vTextureCoord;

            uniform vec2 uResolution;

            uniform float uMinGridSize;
            uniform float uMaxGridSize;

            uniform float uTime;

            uniform float uRevealProgress;

            uniform vec2 uCircleOffset;
            uniform float uCircleEdgeSoftness;

            uniform vec2 uLightPositions[3];
            uniform float uLightIntensities[3];
            uniform float uLightRadius;

            uniform float uEdgeTransitionRange;

            uniform float uBlurStart;
            uniform float uBlurRange;
            uniform float uDistantOpacity;
            uniform float uVerticalFalloff;

            uniform float uCenterDivisor;

            void main() {

                vec2 coord = vTextureCoord * uResolution;

                // Global circle mask setup

                vec2 canvasCenter = uResolution / uCenterDivisor + uCircleOffset;
                float circleRadius = min(uResolution.x, uResolution.y) * 0.6 * uRevealProgress;
                float circleEdge = circleRadius * uCircleEdgeSoftness;

                float distToCenter = length(coord - canvasCenter);

                float circleMask = smoothstep(circleRadius, circleRadius - circleEdge, distToCenter);

                // Soft circular mask without gooey

                float gridFactor = smoothstep(circleRadius - uEdgeTransitionRange, circleRadius, distToCenter);
                gridFactor *= (1.0 - smoothstep(circleRadius, circleRadius + 1.0, distToCenter));
                float gridSize = mix(uMinGridSize, uMaxGridSize, gridFactor);

                float squareSize = 1.5;

                float gap = (gridSize - squareSize) / 2.0;

                float radius = squareSize / 2.0;

                vec2 cell = floor(coord / gridSize);

                vec2 posInCell = mod(coord, gridSize);

                vec2 center = vec2(gridSize / 2.0, gridSize / 2.0);

                vec2 diff = abs(posInCell - center);

                float maxDiff = max(diff.x, diff.y);

                float edge = 0.2;

                float mask = smoothstep(radius + edge, radius - edge, maxDiff);

                float random = fract(sin(dot(cell, vec2(12.9898, 78.233))) * 43758.5453);

                vec3 bgColor = vec3(13.0/255.0, 12.0/255.0, 20.0/255.0);
                vec3 dotColor = vec3(126.0/255.0, 101.0/255.0, 187.0/255.0);

                 float distFromCenter = length(coord - canvasCenter);
                 float distFactor = smoothstep(0.0, circleRadius, distFromCenter);
                 float verticalFactor = 1.0 - (coord.y / uResolution.y);
                 verticalFactor = pow(verticalFactor, uVerticalFalloff);
                 float baseOpacity = 0.5 + 0.5 * sin(uTime * 2.0 + random * 6.28318);
                 float fadeOpacity = baseOpacity * (1.0 - distFactor) * verticalFactor * uDistantOpacity;
                 float blurFactor = uBlurStart + distFactor * uBlurRange;
                 float fadeMask = smoothstep(radius + blurFactor, radius - blurFactor, maxDiff);
                 vec3 innerColor = mix(bgColor, dotColor, fadeMask * fadeOpacity);

                // Add separate light effects blended into dots
                for(int i = 0; i < 3; i++) {
                    float lightDist = length(coord - uLightPositions[i]);
                    float lightMask = smoothstep(uLightRadius, uLightRadius - 110.0, lightDist);
                    innerColor += dotColor * lightMask * uLightIntensities[i] * mask;
                }

                vec3 color = mix(bgColor, innerColor, circleMask);

                gl_FragColor = vec4(color, 1.0);

            }

        `;

        const uniforms = {

            uMinGridSize: 3.4,
            uMaxGridSize: 3.4,

            uResolution: [app.screen.width, app.screen.height],

            uTime: 0.0,

            uRevealProgress: 0.0,

            uCircleOffset: new Float32Array([0.0, 0.0]),
            uCircleEdgeSoftness: 1.0,

            uLightPositions: new Float32Array([0,0,0,0,0,0]),
            uLightIntensities: [0,0,0],
            uLightRadius: 100.0,

            uEdgeTransitionRange: 150.0,

            uBlurStart: 0.2,
            uBlurRange: 0.5,
            uDistantOpacity: 1.0,
            uVerticalFalloff: 1.0,

            uCenterDivisor: 2.0,

        };

        let relativeCircleOffset = new Float32Array([1/2.35 - 0.5, 1/2.35 - 0.5]);

        function updateCircleOffset() {
            uniforms.uCircleOffset[0] = relativeCircleOffset[0] * app.screen.width;
            uniforms.uCircleOffset[1] = relativeCircleOffset[1] * app.screen.height;
        }

        updateCircleOffset();

        const filter = new PIXI.Filter(undefined, fragmentShader, uniforms);

        const rect = new PIXI.Graphics();

        rect.beginFill(0x0D0C14);

        rect.drawRect(0, 0, app.screen.width, app.screen.height);

        rect.endFill();

        rect.filters = [filter];

        app.stage.addChild(rect);

        window.addEventListener('resize', () => {

            app.renderer.resize(container.clientWidth, container.clientHeight);

            uniforms.uResolution = [app.screen.width, app.screen.height];

            rect.width = app.screen.width;

            rect.height = app.screen.height;

            updateCircleOffset();
            if (xOffsetController) xOffsetController.setValue(uniforms.uCircleOffset[0]);
            if (yOffsetController) yOffsetController.setValue(uniforms.uCircleOffset[1]);

            // Trigger media query check after resize
            if (controls.enableResponsive) {
                Object.keys(mediaQueries).forEach(key => {
                    if (mediaQueries[key].mq.matches) {
                        controls.centerDivisor = mediaQueries[key].value;
                        uniforms.uCenterDivisor = mediaQueries[key].value;
                        controls.currentBreakpoint = key;
                        if (centerDivisorController) {
                            centerDivisorController.setValue(mediaQueries[key].value);
                        }
                        if (breakpointController) {
                            breakpointController.setValue(key);
                        }
                    }
                });
            }

        });

        let time = 0;

        app.ticker.add((delta) => {

            time += delta / 60;

            uniforms.uTime = time;

        });

        // Define spawnLight function
        function spawnLight(index) {
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            const minDim = Math.min(app.screen.width, app.screen.height);
            const minDistFromCenter = minDim * 0.2;
            const minDistFromOthers = minDim * 0.15;
            let x, y;
            let valid = false;
            while (!valid) {
                x = Math.random() * app.screen.width;
                y = Math.random() * app.screen.height;
                const distCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                if (distCenter < minDistFromCenter) continue;
                valid = true;
                for (let i = 0; i < 3; i++) {
                    if (i === index) continue;
                    const otherX = uniforms.uLightPositions[i * 2];
                    const otherY = uniforms.uLightPositions[i * 2 + 1];
                    if (uniforms.uLightIntensities[i] > 0) {
                        const distOther = Math.sqrt((x - otherX) ** 2 + (y - otherY) ** 2);
                        if (distOther < minDistFromOthers) {
                            valid = false;
                            break;
                        }
                    }
                }
            }
            uniforms.uLightPositions[index * 2] = x;
            uniforms.uLightPositions[index * 2 + 1] = y;
            gsap.timeline({ onComplete: () => spawnLight(index) })
                .to(uniforms.uLightIntensities, { [index]: 1, duration: 1.5, ease: "power2.inOut" })
                .to(uniforms.uLightIntensities, { [index]: 0, duration: 1.5, ease: "power2.inOut", delay: Math.random() * 2 + 1 });
        }

        gsap.registerPlugin(ScrollTrigger);

        gsap.to(uniforms, {
            uRevealProgress: 1,
            duration: 1.5,
            ease: "power3.out",
            scrollTrigger: {
                trigger: container,
                start: "top 80%",
                once: true,
            },
            onComplete: () => {
                spawnLight(0);
                setTimeout(() => spawnLight(1), 1000);
                setTimeout(() => spawnLight(2), 2000);
            }
        });

        const controls = {
          minGridSize: 3.4,
          maxGridSize: 3.4,
          lightRadius: 100.0,
          revealProgress: 0.0,
          circleOffsetX: 0.0,
          circleOffsetY: 0.0,
          circleEdgeSoftness: 1.0,
          edgeTransitionRange: 150.0,
          blurStart: 0.2,
          blurRange: 0.5,
          distantOpacity: 1.0,
          verticalFalloff: 1.0,
          centerDivisor: 2.0,
          enableResponsive: true,
          currentBreakpoint: 'unknown'
        };

        let xOffsetController, yOffsetController;

        // Media Query System for Center Divisor
        const mediaQueryConfig = {
          mobile: { query: '(max-width: 320px)', value: 2.4 },
          mobileL: { query: '(min-width: 321px) and (max-width: 568px)', value: 2.2 },
          tablet: { query: '(min-width: 569px) and (max-width: 768px)', value: 2.0 },
          desktop: { query: '(min-width: 769px) and (max-width: 1432px)', value: 1.8 },
          largeDesktop: { query: '(min-width: 1433px)', value: 1.6 }
        };

        let mediaQueries = {};

        function initMediaQueries() {
          Object.keys(mediaQueryConfig).forEach(key => {
            const config = mediaQueryConfig[key];
            const mq = window.matchMedia(config.query);

            mediaQueries[key] = {
              mq: mq,
              value: config.value,
              handler: (e) => {
                if (e.matches && controls.enableResponsive) {
                  controls.centerDivisor = config.value;
                  uniforms.uCenterDivisor = config.value;
                  controls.currentBreakpoint = key;
                  console.log(`Switched to ${key} breakpoint, center divisor: ${config.value}`);
                  if (centerDivisorController) {
                    centerDivisorController.setValue(config.value);
                  }
                  if (breakpointController) {
                    breakpointController.setValue(key);
                  }
                }
              }
            };

            mq.addListener(mediaQueries[key].handler);

            // Check initial state
            if (mq.matches && controls.enableResponsive) {
              controls.centerDivisor = config.value;
              uniforms.uCenterDivisor = config.value;
              controls.currentBreakpoint = key;
            }
          });
        }

                function updateMediaQueryConfig(breakpoint, value) {
          if (mediaQueryConfig[breakpoint]) {
            mediaQueryConfig[breakpoint].value = value;
            mediaQueries[breakpoint].value = value;

            // Trigger update if current breakpoint matches
            if (mediaQueries[breakpoint].mq.matches && controls.enableResponsive) {
              controls.centerDivisor = value;
              uniforms.uCenterDivisor = value;
              console.log(`Updated ${breakpoint} breakpoint to ${value}`);
            }
          }
        }

        function getCurrentBreakpoint() {
          for (let key in mediaQueries) {
            if (mediaQueries[key].mq.matches) {
              return key;
            }
          }
          return 'unknown';
        }

        // Initialize media queries
        initMediaQueries();

        let centerDivisorController, breakpointController;

        const gui = new dat.GUI();

        const mainRevealFolder = gui.addFolder('Main Reveal');
        mainRevealFolder.add(controls, 'revealProgress', 0.0, 1.0, 0.01).name('Reveal Progress').onChange(v => { uniforms.uRevealProgress = v; });
        mainRevealFolder.add(controls, 'circleEdgeSoftness', 0.1, 2.0).name('Edge Softness').onChange(v => { uniforms.uCircleEdgeSoftness = v; });
        mainRevealFolder.open();

        const circleFolder = gui.addFolder('Circle Position');
        xOffsetController = circleFolder.add(controls, 'circleOffsetX', -400, 400).name('X Offset').onChange(v => {
            relativeCircleOffset[0] = v / app.screen.width;
            uniforms.uCircleOffset[0] = v;
        });
        yOffsetController = circleFolder.add(controls, 'circleOffsetY', -400, 400).name('Y Offset').onChange(v => {
            relativeCircleOffset[1] = v / app.screen.height;
            uniforms.uCircleOffset[1] = v;
        });
        circleFolder.open();

        const gridFolder = gui.addFolder('Grid Density');
        gridFolder.add(controls, 'minGridSize', 1.0, 20.0).name('Center Size').onChange(v => { uniforms.uMinGridSize = v; });
        gridFolder.add(controls, 'maxGridSize', 1.0, 20.0).name('Edge Size').onChange(v => { uniforms.uMaxGridSize = v; });
        gridFolder.add(controls, 'edgeTransitionRange', 50, 300).name('Edge Transition').onChange(v => { uniforms.uEdgeTransitionRange = v; });
        gridFolder.open();

        gui.add(controls, 'lightRadius', 50.0, 200.0).onChange(v => { uniforms.uLightRadius = v; });

        const distantFolder = gui.addFolder('Distant Grid');
        distantFolder.add(controls, 'blurStart', 0.0, 1.0).name('Min Blur').onChange(v => { uniforms.uBlurStart = v; });
        distantFolder.add(controls, 'blurRange', 0.0, 2.0).name('Blur Range').onChange(v => { uniforms.uBlurRange = v; });
        distantFolder.add(controls, 'distantOpacity', 0.0, 1.0).name('Opacity').onChange(v => { uniforms.uDistantOpacity = v; });
        distantFolder.add(controls, 'verticalFalloff', 0.1, 5.0).name('Vertical Falloff').onChange(v => { uniforms.uVerticalFalloff = v; });
        distantFolder.open();

                const centerFolder = gui.addFolder('Center Positioning');
        breakpointController = centerFolder.add(controls, 'currentBreakpoint').name('Current Breakpoint').listen();
        centerFolder.add(controls, 'enableResponsive').name('Enable Responsive').onChange(v => {
          if (v) {
            // Re-trigger current media query
            Object.keys(mediaQueries).forEach(key => {
              if (mediaQueries[key].mq.matches) {
                controls.centerDivisor = mediaQueries[key].value;
                uniforms.uCenterDivisor = mediaQueries[key].value;
                controls.currentBreakpoint = key;
                centerDivisorController.setValue(mediaQueries[key].value);
                breakpointController.setValue(key);
              }
            });
          }
        });
        centerDivisorController = centerFolder.add(controls, 'centerDivisor', 1.0, 3.0).name('Center Divisor').onChange(v => {
          uniforms.uCenterDivisor = v;
          if (controls.enableResponsive) {
            // Update current breakpoint value
            Object.keys(mediaQueries).forEach(key => {
              if (mediaQueries[key].mq.matches) {
                updateMediaQueryConfig(key, v);
              }
            });
          }
        });
        centerFolder.open();

        const responsiveFolder = gui.addFolder('Responsive Breakpoints');
        responsiveFolder.add(mediaQueryConfig.mobile, 'value', 1.0, 3.0).name('Mobile (≤320px)').onChange(v => updateMediaQueryConfig('mobile', v));
        responsiveFolder.add(mediaQueryConfig.mobileL, 'value', 1.0, 3.0).name('Mobile L (321-568px)').onChange(v => updateMediaQueryConfig('mobileL', v));
        responsiveFolder.add(mediaQueryConfig.tablet, 'value', 1.0, 3.0).name('Tablet (569-768px)').onChange(v => updateMediaQueryConfig('tablet', v));
        responsiveFolder.add(mediaQueryConfig.desktop, 'value', 1.0, 3.0).name('Desktop (769-1432px)').onChange(v => updateMediaQueryConfig('desktop', v));
        responsiveFolder.add(mediaQueryConfig.largeDesktop, 'value', 1.0, 3.0).name('Large Desktop (1433px+)').onChange(v => updateMediaQueryConfig('largeDesktop', v));
        responsiveFolder.close();

        xOffsetController.setValue(uniforms.uCircleOffset[0]);
        yOffsetController.setValue(uniforms.uCircleOffset[1]);
    </script>
</body>

</html>
