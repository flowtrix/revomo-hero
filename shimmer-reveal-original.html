<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Convergence Portal Effect</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0D0C14;
            color: #000000;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .reveal-container {
            position: relative;
            width: 80vw;
            height: 80vw;
            max-width: 800px;
            max-height: 800px;
            margin: 2rem auto;
            opacity: 0;
        }

        .reveal-container .dot-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
    </style>
</head>

<body>
    <div class="reveal-container">
        <div class="dot-field"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"
        integrity="sha512-WoO4Ih0CDOSLYafy22wZD/mcJ7k0ESLqtQsFa6zFKnEUrbtuGU+GkLtVhgt93xa2qewG5gKEC6CWlN8OaCTSVg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script type="module">
        const container = document.querySelector('.dot-field');

        const app = new PIXI.Application({
            width: container.clientWidth,
            height: container.clientHeight,
            backgroundColor: 0x0D0C14,
            backgroundAlpha: 1,
            antialias: true,
            autoDensity: true,
            resolution: window.devicePixelRatio,
        });

        container.appendChild(app.view);

        const fragmentShader = `
            precision mediump float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform float uMinGridSize;
            uniform float uMaxGridSize;
            uniform float uTime;
            uniform float uRevealProgress;
            uniform vec2 uCircleOffset;
            uniform float uCircleEdgeSoftness;
            uniform vec2 uLightPositions[3];
            uniform float uLightIntensities[3];
            uniform float uLightRadius;
            uniform float uEdgeTransitionRange;
            uniform float uBlurStart;
            uniform float uBlurRange;
            uniform float uDistantOpacity;
            uniform float uVerticalFalloff;

            // Glow effect uniforms
            uniform float uGlowIntensity;
            uniform float uGlowSize;
            uniform vec2 uGlowOffset;
            uniform float uOutsideShimmerOpacity;
            // Debug stroke controls
            uniform bool uShowDebugStrokes;
            uniform float uStrokeWidth;
            uniform float uSlitTopWidth;
            uniform float uSlitBottomWidth;
            uniform float uSlitHeight;
            uniform float uCurveIntensity;
            uniform float uCurvePosition;
            uniform float uCurveSpread;
            uniform float uRoundingAmount;
            // Inward curve controls for convergence
            uniform float uInwardCurveIntensity;
            uniform float uInwardCurvePosition;
            uniform float uInwardCurveWidth;

            // FIXED S-Curve portal with proper convergence to a point
            float sdVerticalSlit(vec2 p, vec2 center, float topWidth, float bottomWidth, float height, float size) {
                p = (p - center) / size;

                // Normalize Y to range from -1 (bottom) to 1 (top)
                float normalizedY = p.y / height;

                // Convert from [-1,1] to [0,1] where 1 is top, 0 is bottom
                float t = (normalizedY + 1.0) * 0.5;

                // Distance from top (0 at top, 1 at bottom)
                float distanceFromTop = 1.0 - t;

                // Base linear width interpolation
                float linearWidth = mix(bottomWidth, topWidth, t);

                // S-CURVE METHODOLOGY (Outward bulge) - Apply only in middle sections
                float curveCenter = uCurvePosition;
                float curveWidth = uCurveSpread;

                // Calculate distance from curve center
                float distanceFromCurveCenter = abs(distanceFromTop - curveCenter);

                // S-Curve using smooth sigmoid-like function
                float normalizedDist = distanceFromCurveCenter / curveWidth;
                float sCurveValue = 1.0 / (1.0 + exp(4.0 * (normalizedDist - 0.5)));

                // Apply curve intensity with falloff near convergence zone
                float curveMultiplier = uCurveIntensity * bottomWidth;
                float bulgeFactor = 1.0 + (sCurveValue * curveMultiplier);

                // FIXED CONVERGENCE LOGIC
                float inwardCurveCenter = uInwardCurvePosition;
                float inwardCurveRange = uInwardCurveWidth;

                // Calculate convergence zone (near top point)
                float distanceFromInwardCenter = abs(distanceFromTop - inwardCurveCenter);
                float convergenceZone = 1.0 - (distanceFromInwardCenter / inwardCurveRange);
                convergenceZone = max(0.0, convergenceZone);
                convergenceZone = smoothstep(0.0, 1.0, convergenceZone);

                // In the convergence zone, gradually reduce the S-curve effect
                // and apply inward convergence
                float effectiveOutwardBulge = bulgeFactor;

                if (convergenceZone > 0.0) {
                    // Reduce outward bulge in convergence zone
                    effectiveOutwardBulge = mix(bulgeFactor, 1.0, convergenceZone * 0.7);

                    // Apply inward convergence - this narrows the shape toward the top
                    float convergenceStrength = uInwardCurveIntensity * convergenceZone;

                    // Create smooth inward curve based on horizontal position
                    float normalizedX = abs(p.x) / linearWidth;
                    normalizedX = clamp(normalizedX, 0.0, 1.0);

                    // Parabolic convergence - stronger effect toward edges
                    float convergenceCurve = normalizedX * normalizedX;

                    // Additional convergence based on distance from top
                    float topProximity = 1.0 - distanceFromTop;
                    topProximity = smoothstep(0.0, 1.0, topProximity);

                    // Calculate convergence reduction factor
                    float convergenceReduction = convergenceStrength * convergenceCurve * topProximity;

                    // Apply convergence by reducing the effective width
                    effectiveOutwardBulge *= (1.0 - convergenceReduction);
                }

                // Apply the final width calculation
                float currentWidth = linearWidth * effectiveOutwardBulge;

                // FIXED: Enhanced convergence to a sharp point at the very top
                // Add exponential narrowing for the top 5% of the shape
                float topPointZone = smoothstep(0.95, 1.0, t);
                if (topPointZone > 0.0) {
                    // Force width to approach zero at the very tip using a linear mix for a sharper point
                    currentWidth = mix(currentWidth, 0.0, topPointZone);
                }

                // Create horizontal bounds
                float horizontalDist = abs(p.x) - currentWidth;

                // Keep vertical bounds controlled
                float verticalDist = abs(p.y) - height;

                // FIXED: Adaptive rounding that reduces to zero at the tip
                float tipFactor = 1.0 - pow(topPointZone, 2.0);
                float adaptiveRounding = uRoundingAmount * (1.0 + sCurveValue * 0.3) * tipFactor;

                // REMOVED: Special handling for the tip was creating a flat top.
                // The main SDF path now handles the point correctly due to improved width convergence.

                // Combine distances with rounding
                float combinedDist = max(horizontalDist, verticalDist);
                return combinedDist - adaptiveRounding;
            }

            // Linear gradient function
            vec3 linearGradient(float t, vec3 color1, vec3 color2) {
                return mix(color1, color2, clamp(t, 0.0, 1.0));
            }

            // Radial gradient function
            vec3 radialGradient(vec2 p, vec2 center, float radius, vec3 color1, vec3 color2) {
                float dist = length(p - center) / radius;
                return mix(color1, color2, clamp(dist, 0.0, 1.0));
            }

            // Blend mode functions matching SVG
            vec3 blendScreen(vec3 base, vec3 blend) {
                return 1.0 - (1.0 - base) * (1.0 - blend);
            }

            vec3 blendHardLight(vec3 base, vec3 blend) {
                return mix(
                    2.0 * base * blend,
                    1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
                    step(0.5, blend)
                );
            }

            vec3 blendPlusLighter(vec3 base, vec3 blend) {
                return min(base + blend, 1.0);
            }

            // Generate glow effect layers for oval portal shape
            vec3 createGlowEffect(vec2 coord) {
                vec2 center = uResolution * 0.5 + uGlowOffset;
                float scale = min(uResolution.x, uResolution.y) * uGlowSize * uRevealProgress;

                // Get distance to vertical slit shape with S-curves
                float dist = sdVerticalSlit(coord, center, uSlitTopWidth, uSlitBottomWidth, uSlitHeight, scale);

                // Define colors from the SVG exactly
                vec3 darkBg = vec3(14.0/255.0, 12.0/255.0, 21.0/255.0);
                vec3 purpleLight = vec3(177.0/255.0, 154.0/255.0, 232.0/255.0);
                vec3 purpleMid = vec3(111.0/255.0, 63.0/255.0, 227.0/255.0);
                vec3 purpleBright = vec3(217.0/255.0, 201.0/255.0, 255.0/255.0);
                vec3 purpleUp = mix(darkBg, purpleMid, 0.23);

                vec3 finalColor = darkBg;

                // Layer 1: Main shape with screen blend (opacity="0.56")
                float mainShape = smoothstep(0.02, -0.02, dist);
                float gradientT = (coord.y - center.y + scale * 0.5) / scale;
                vec3 mainGrad = linearGradient(gradientT, purpleUp, purpleLight);
                finalColor = blendScreen(finalColor, mainGrad * mainShape * 0.56);

                // Layer 2: Hard light blend (opacity="0.42")
                float hardLightShape = smoothstep(0.015, -0.015, dist);
                vec3 hardLightGrad = linearGradient(gradientT, vec3(0.0), purpleLight);
                vec3 hardLightBlended = blendHardLight(finalColor, hardLightGrad);
                finalColor = mix(finalColor, hardLightBlended, hardLightShape * 0.42);

                // Layer 3: First plus-lighter with blur (opacity="0.66", stdDeviation="40")
                float blur1Shape = smoothstep(0.06, -0.06, dist);
                vec3 blur1Color = mix(purpleMid * 0.23, purpleMid, gradientT);
                finalColor = blendPlusLighter(finalColor, blur1Color * blur1Shape * 0.66);

                // Layer 4: Second plus-lighter with smaller blur (opacity="0.66", stdDeviation="8.55")
                float blur2Shape = smoothstep(0.025, -0.025, dist);
                vec3 blur2Color = mix(vec3(0.0), purpleMid, gradientT);
                finalColor = blendPlusLighter(finalColor, blur2Color * blur2Shape * 0.66);

                // Layer 5: Third plus-lighter with different blur (opacity="0.76", stdDeviation="8.55")
                float blur3Shape = smoothstep(0.025, -0.025, dist);
                vec3 blur3Color = mix(vec3(0.0), purpleBright, gradientT);
                finalColor = blendPlusLighter(finalColor, blur3Color * blur3Shape * 0.76);

                // Layer 6: Outer glow with large blur (opacity="0.58", stdDeviation="24")
                float outerGlow = smoothstep(0.12, -0.05, dist);
                vec3 outerColor = mix(vec3(0.0), purpleBright, gradientT);
                finalColor = blendPlusLighter(finalColor, outerColor * outerGlow * 0.58);

                // Background radial gradients
                vec2 radialCenter1 = center + vec2(0.0, -scale * 0.2);
                vec3 radial1 = radialGradient(coord, radialCenter1, scale * 1.5,
                    vec3(29.0/255.0, 28.0/255.0, 43.0/255.0), vec3(0.0));
                finalColor = mix(finalColor, radial1, 0.25);

                vec2 radialCenter2 = center + vec2(0.0, scale * 0.1);
                vec3 radial2 = radialGradient(coord, radialCenter2, scale * 0.9,
                    vec3(78.0/255.0, 60.0/255.0, 190.0/255.0) * 0.26, vec3(0.0));
                finalColor = blendScreen(finalColor, radial2 * 0.15);

                return finalColor;
            }

            void main() {
                vec2 coord = vTextureCoord * uResolution;

                // Create glow effect (replaces SVG)
                vec3 glowColor = createGlowEffect(coord);

                // Get slit mask for shimmer intensity modulation
                vec2 center = uResolution * 0.5 + uGlowOffset;
                float scale = min(uResolution.x, uResolution.y) * uGlowSize * uRevealProgress;
                float shapeDist = sdVerticalSlit(coord, center, uSlitTopWidth, uSlitBottomWidth, uSlitHeight, scale);
                float shapeMask = smoothstep(0.02, -0.02, shapeDist);

                // Calculate shimmer opacity: full inside glow, fainted outside
                float shimmerOpacity = mix(uOutsideShimmerOpacity, 1.0, shapeMask);

                // Shimmer grid calculation (now rendered everywhere with varying opacity)
                float gridSize = uMinGridSize;
                float squareSize = 1.5;
                float radius = squareSize / 2.0;

                vec2 cell = floor(coord / gridSize);
                vec2 posInCell = mod(coord, gridSize);
                vec2 cellCenter = vec2(gridSize / 2.0, gridSize / 2.0);
                vec2 diff = abs(posInCell - cellCenter);
                float maxDiff = max(diff.x, diff.y);

                float edge = 0.2;
                float mask = smoothstep(radius + edge, radius - edge, maxDiff);
                float random = fract(sin(dot(cell, vec2(12.9898, 78.233))) * 43758.5453);

                vec3 dotColor = vec3(200.0/255.0, 180.0/255.0, 255.0/255.0);

                float distFromCenter = length(coord - center);
                float distFactor = distFromCenter / scale;
                float verticalFactor = 1.0 - (coord.y / uResolution.y);
                verticalFactor = pow(verticalFactor, uVerticalFalloff);

                float baseOpacity = 0.3 + 0.4 * sin(uTime * 2.0 + random * 6.28318);
                float fadeOpacity = baseOpacity * (1.0 - distFactor * 0.3) * verticalFactor * uDistantOpacity;

                // Apply shimmer opacity modulation
                vec3 shimmerColor = dotColor * mask * fadeOpacity * shimmerOpacity;

                // Add separate light effects
                for(int i = 0; i < 3; i++) {
                    float lightDist = length(coord - uLightPositions[i]);
                    float lightMask = smoothstep(uLightRadius, uLightRadius - 110.0, lightDist);
                    shimmerColor += dotColor * lightMask * uLightIntensities[i] * mask * 0.8 * shimmerOpacity;
                }

                // Blend shimmer with glow using plus-lighter
                glowColor = blendPlusLighter(glowColor, shimmerColor);

                // DEBUG STROKES for convergence visualization
                if (uShowDebugStrokes) {
                    vec2 debugCoord = vTextureCoord * uResolution;
                    vec2 debugCenter = uResolution * 0.5 + uGlowOffset;
                    float debugScale = min(uResolution.x, uResolution.y) * uGlowSize * uRevealProgress;

                    // Calculate debug parameters
                    vec2 debugP = (debugCoord - debugCenter) / debugScale;
                    float debugNormalizedY = debugP.y / uSlitHeight;
                    float debugT = (debugNormalizedY + 1.0) * 0.5;
                    float debugDistanceFromTop = 1.0 - debugT;

                    // Debug convergence zone boundaries
                    float debugInwardCenter = uInwardCurvePosition;
                    float debugInwardRange = uInwardCurveWidth;
                    float debugDistanceFromInwardCenter = abs(debugDistanceFromTop - debugInwardCenter);
                    float debugInwardZone = 1.0 - (debugDistanceFromInwardCenter / debugInwardRange);
                    debugInwardZone = max(0.0, debugInwardZone);

                    // Draw convergence zone outline
                    float zoneTopBoundary = abs((debugDistanceFromTop - (debugInwardCenter - debugInwardRange)));
                    float zoneBottomBoundary = abs((debugDistanceFromTop - (debugInwardCenter + debugInwardRange)));
                    float zoneBoundaryStroke = step(zoneTopBoundary, uStrokeWidth) + step(zoneBottomBoundary, uStrokeWidth);

                    // Draw convergence center line
                    float centerLineStroke = step(abs(debugDistanceFromTop - debugInwardCenter), uStrokeWidth);

                    // Draw convergence intensity visualization
                    float intensityVis = debugInwardZone * 0.5;

                    // Top connection factor visualization
                    float topConnectionFactor = 1.0 - smoothstep(0.0, 0.3, debugDistanceFromTop);
                    float topConnectionStroke = topConnectionFactor * 0.3;

                    // Combine debug strokes
                    vec3 debugColor = vec3(1.0, 0.0, 0.0) * zoneBoundaryStroke +      // Red zone boundaries
                                      vec3(0.0, 1.0, 0.0) * centerLineStroke +        // Green center line
                                      vec3(0.0, 0.0, 1.0) * intensityVis +           // Blue intensity
                                      vec3(1.0, 1.0, 0.0) * topConnectionStroke;     // Yellow top connection

                    // Add debug strokes to final color
                    glowColor = mix(glowColor, debugColor, min(length(debugColor), 0.8));
                }

                gl_FragColor = vec4(glowColor, 1.0);
            }
        `;

        const uniforms = {
            uMinGridSize: 3.3,
            uMaxGridSize: 3.3,
            uResolution: [app.screen.width, app.screen.height],
            uTime: 0.0,
            uRevealProgress: 0.0,
            uCircleOffset: new Float32Array([0.0, 0.0]),
            uCircleEdgeSoftness: 1.0,
            uLightPositions: new Float32Array([0, 0, 0, 0, 0, 0]),
            uLightIntensities: [0, 0, 0],
            uLightRadius: 61.0,
            uEdgeTransitionRange: 150.0,
            uBlurStart: 0.2,
            uBlurRange: 0.5,
            uDistantOpacity: 0.6,
            uVerticalFalloff: 5.0,
            // Glow effect uniforms - updated to match your settings
            uGlowIntensity: 1.0,
            uGlowSize: 0.12,
            uGlowOffset: new Float32Array([-70.0, -200.0]),
            uOutsideShimmerOpacity: 0.16,
            // Curved triangular portal controls - updated to match your settings
            uSlitTopWidth: 0.001,   // Top Point
            uSlitBottomWidth: 1.8,  // Bottom Width
            uSlitHeight: 0.92,      // Height
            // S-Curve controls - updated to match your settings
            uCurveIntensity: 0.49,  // Curve Intensity
            uCurvePosition: 0.72,    // Curve Position
            uCurveSpread: 0.57,     // Curve Spread
            uRoundingAmount: 0.0,  // Rounding
            // FIXED Converging rounded shapes controls - updated to match your settings
            uInwardCurveIntensity: 2.0,  // Convergence Intensity
            uInwardCurvePosition: 0.35,  // Convergence Position
            uInwardCurveWidth: 0.8,      // Convergence Range
            // Debug stroke controls
            uShowDebugStrokes: false,    // Toggle debug strokes on/off
            uStrokeWidth: 0.005,         // Width of debug strokes
        };

        const filter = new PIXI.Filter(undefined, fragmentShader, uniforms);

        const rect = new PIXI.Graphics();
        rect.beginFill(0x0D0C14);
        rect.drawRect(0, 0, app.screen.width, app.screen.height);
        rect.endFill();
        rect.filters = [filter];
        app.stage.addChild(rect);

        // Responsive scaling
        window.addEventListener('resize', () => {
            app.renderer.resize(container.clientWidth, container.clientHeight);
            uniforms.uResolution = [app.screen.width, app.screen.height];
            rect.width = app.screen.width;
            rect.height = app.screen.height;
        });

        let time = 0;
        app.ticker.add((delta) => {
            time += delta / 60;
            uniforms.uTime = time;
        });

        // Define spawnLight function
        function spawnLight(index) {
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            const minDim = Math.min(app.screen.width, app.screen.height);
            const minDistFromCenter = minDim * 0.2;
            const minDistFromOthers = minDim * 0.15;
            let x, y;
            let valid = false;
            while (!valid) {
                x = Math.random() * app.screen.width;
                y = Math.random() * app.screen.height;
                const distCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                if (distCenter < minDistFromCenter) continue;
                valid = true;
                for (let i = 0; i < 3; i++) {
                    if (i === index) continue;
                    const otherX = uniforms.uLightPositions[i * 2];
                    const otherY = uniforms.uLightPositions[i * 2 + 1];
                    if (uniforms.uLightIntensities[i] > 0) {
                        const distOther = Math.sqrt((x - otherX) ** 2 + (y - otherY) ** 2);
                        if (distOther < minDistFromOthers) {
                            valid = false;
                            break;
                        }
                    }
                }
            }
            uniforms.uLightPositions[index * 2] = x;
            uniforms.uLightPositions[index * 2 + 1] = y;
            gsap.timeline({
                    onComplete: () => spawnLight(index)
                })
                .to(uniforms.uLightIntensities, {
                    [index]: 1,
                    duration: 1.5,
                    ease: "power2.inOut"
                })
                .to(uniforms.uLightIntensities, {
                    [index]: 0,
                    duration: 1.5,
                    ease: "power2.inOut",
                    delay: Math.random() * 2 + 1
                });
        }

        gsap.registerPlugin(ScrollTrigger);

        // Simplified reveal animation - everything is now in shader
        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: ".reveal-container",
                start: "top 80%",
                once: true,
            }
        });

        // Container and glow reveal
        tl.to(".reveal-container", {
            opacity: 1,
            duration: 1.5,
            ease: "power3.out"
        })
        // Glow effect reveal
        .to(uniforms, {
            uRevealProgress: 1,
            duration: 2.5,
            ease: "power3.out"
        }, 0.3)
        // Start lights after glow appears
        .call(() => {
            spawnLight(0);
            setTimeout(() => spawnLight(1), 1000);
            setTimeout(() => spawnLight(2), 2000);
        }, null, 2.0);

        // Debug controls - matching your exact settings from the image
        const controls = {
            minGridSize: 3.3,
            maxGridSize: 3.3,
            lightRadius: 61.0,
            revealProgress: 0.0,
            circleOffsetX: 0.0,
            circleOffsetY: 0.0,
            circleEdgeSoftness: 1.0,
            edgeTransitionRange: 150.0,
            blurStart: 0.2,
            blurRange: 0.5,
            distantOpacity: 0.6,
            verticalFalloff: 5.0,
            // Glow controls
            glowIntensity: 1.0,
            glowSize: 0.12,
            glowOffsetX: -70.0,
            glowOffsetY: -200.0,
            outsideShimmerOpacity: 0.16,
            // Curved triangular portal controls - matching your settings
            slitTopWidth: 0.001,    // Top Point
            slitBottomWidth: 1.8,   // Bottom Width
            slitHeight: 0.92,       // Height
            // S-Curve controls - matching your settings
            curveIntensity: 0.49,   // Curve Intensity
            curvePosition: 0.72,     // Curve Position
            curveSpread: 0.57,      // Curve Spread
            roundingAmount: 0.0,   // Rounding
            // FIXED Converging rounded shapes controls - matching your settings
            inwardCurveIntensity: 2.0,  // Convergence Intensity
            inwardCurvePosition: 0.35,  // Convergence Position
            inwardCurveWidth: 0.8,      // Convergence Range
            // Debug stroke controls
            showDebugStrokes: false,    // Toggle debug strokes on/off
            strokeWidth: 0.005          // Width of debug strokes
        };

        const gui = new dat.GUI();

        const mainRevealFolder = gui.addFolder('Main Reveal');
        mainRevealFolder.add(controls, 'revealProgress', 0.0, 1.0, 0.01).name('Reveal Progress').onChange(v => {
            uniforms.uRevealProgress = v;
        });
        mainRevealFolder.open();

        const shapeFolder = gui.addFolder('Curved Portal Shape');
        shapeFolder.add(controls, 'slitTopWidth', 0.001, 0.1).name('Top Point').onChange(v => {
            uniforms.uSlitTopWidth = v;
        });
        shapeFolder.add(controls, 'slitBottomWidth', 0.5, 2.0).name('Bottom Width').onChange(v => {
            uniforms.uSlitBottomWidth = v;
        });
        shapeFolder.add(controls, 'slitHeight', 0.5, 2.0).name('Height').onChange(v => {
            uniforms.uSlitHeight = v;
        });
        shapeFolder.open();

        const sCurveFolder = gui.addFolder('S-Curve Controls (Substantial Curve)');
        sCurveFolder.add(controls, 'curveIntensity', 0.0, 1.0).name('Curve Intensity').onChange(v => {
            uniforms.uCurveIntensity = v;
        });
        sCurveFolder.add(controls, 'curvePosition', 0.3, 0.9).name('Curve Position').onChange(v => {
            uniforms.uCurvePosition = v;
        });
        sCurveFolder.add(controls, 'curveSpread', 0.1, 0.8).name('Curve Spread').onChange(v => {
            uniforms.uCurveSpread = v;
        });
        sCurveFolder.add(controls, 'roundingAmount', 0.0, 0.2).name('Rounding Amount').onChange(v => {
            uniforms.uRoundingAmount = v;
        });
        sCurveFolder.open();

        const inwardCurveFolder = gui.addFolder('FIXED Convergence');
        inwardCurveFolder.add(controls, 'inwardCurveIntensity', 0.0, 2.0).name('Convergence Intensity').onChange(v => {
            uniforms.uInwardCurveIntensity = v;
        });
        inwardCurveFolder.add(controls, 'inwardCurvePosition', 0.0, 0.8).name('Convergence Position').onChange(v => {
            uniforms.uInwardCurvePosition = v;
        });
        inwardCurveFolder.add(controls, 'inwardCurveWidth', 0.1, 0.8).name('Convergence Range').onChange(v => {
            uniforms.uInwardCurveWidth = v;
        });
        inwardCurveFolder.open();

        const debugFolder = gui.addFolder('Debug Strokes');
        debugFolder.add(controls, 'showDebugStrokes').name('Show Debug Strokes').onChange(v => {
            uniforms.uShowDebugStrokes = v;
        });
        debugFolder.add(controls, 'strokeWidth', 0.005, 0.1).name('Stroke Width').onChange(v => {
            uniforms.uStrokeWidth = v;
        });
        debugFolder.open();

        const glowFolder = gui.addFolder('Glow Effect');
        glowFolder.add(controls, 'glowIntensity', 0.0, 2.0).name('Intensity').onChange(v => {
            uniforms.uGlowIntensity = v;
        });
        glowFolder.add(controls, 'glowSize', 0.1, 1.0).name('Size').onChange(v => {
            uniforms.uGlowSize = v;
        });
        glowFolder.add(controls, 'glowOffsetX', -200, 200).name('X Offset').onChange(v => {
            uniforms.uGlowOffset[0] = v;
        });
        glowFolder.add(controls, 'glowOffsetY', -200, 200).name('Y Offset').onChange(v => {
            uniforms.uGlowOffset[1] = v;
        });

        const shimmerFolder = gui.addFolder('Shimmer Control');
        const gridFolder = shimmerFolder.addFolder('Grid Density');
        gridFolder.add(controls, 'minGridSize', 1.0, 20.0).name('Grid Size').onChange(v => {
            uniforms.uMinGridSize = v;
        });

        shimmerFolder.add(controls, 'outsideShimmerOpacity', 0.0, 1.0).name('Outside Opacity').onChange(v => {
            uniforms.uOutsideShimmerOpacity = v;
        });

        shimmerFolder.add(controls, 'lightRadius', 50.0, 200.0).name('Light Radius').onChange(v => {
            uniforms.uLightRadius = v;
        });

        const distantFolder = shimmerFolder.addFolder('Distant Grid');
        distantFolder.add(controls, 'distantOpacity', 0.0, 1.0).name('Opacity').onChange(v => {
            uniforms.uDistantOpacity = v;
        });
        distantFolder.add(controls, 'verticalFalloff', 0.1, 5.0).name('Vertical Falloff').onChange(v => {
            uniforms.uVerticalFalloff = v;
        });
    </script>
</body>

</html>
